<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>Personal blog of Christian Seyda | Articles by Christian Seyda</title>
    <link rel="shortcut icon" type="image/png" href="//cseyda.github.io/favicon.png">
    <link rel="shortcut icon" type="image/x-icon" href="//cseyda.github.io/favicon.ico">
    <link href="//cseyda.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Personal blog of Christian Seyda Full Atom Feed" />
    <link rel="stylesheet" href="//cseyda.github.io/theme/css/screen.css" type="text/css" />
    <link rel="stylesheet" href="//cseyda.github.io/theme/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="//cseyda.github.io/theme/css/print.css" type="text/css" media="print" />
    <meta name="generator" content="Pelican" />
</head>
<body>
    <header>
        <nav>
            <ul>

                <li class="ephemeral selected"><a href="//cseyda.github.io/author/christian-seyda.html">Christian Seyda</a></li>
                <li><a href="//cseyda.github.io/""">About&nbsp;me</a></li>
                <li><a href="//cseyda.github.io/archives">Blog posts</a></li>
            </ul>
        </nav>
        <div class="header_box">
            <h1><a href="//cseyda.github.io">Personal blog of Christian Seyda</a></h1>
        </div>
    </header>
    <div id="wrapper">
        <div id="content">            <h4 class="date">Apr 17, 2016</h4>

            <article class="post">
                <h2 class="title">
                    <a href="//cseyda.github.io/reading-flow.html" rel="bookmark" title="Permanent Link to &quot;My article reading and consumption&nbsp;flow&quot;">My article reading and consumption&nbsp;flow</a>
                </h2>

                <p>I was overwhelmed. Articles in bookmarks, open tabs, tab groups, sometimes over different browsers and operating systems and even in my todo list … This had to to change. A process for reading was needed.
First step was to open even more tabs and add more bookmarks. But after some reading how others approach this topic, I got to work uncluttering this mess.</p>
<p>In hindsight, the whole process is pretty obvious. It basically works this way:</p>
<ol>
<li>Articles come in</li>
<li>Some are read, some are added to a read-later list</li>
<li>Later, articles from the read-later list are read</li>
</ol>
<p>My implementation is a little more complex, because I added a research process and wanted to take more notes of what I learned (and because I am a complicated person?).</p>
<p>The resulting reading flow can be devided into different parts:</p>
<h1>Documents and decisions</h1>
<p>Usually all articles I read either come from the links gathered by looking something up in my browser, or though my feed reader (<a href="https://inoreader.com">InoReader</a>). These articles can be roughly divided into three types:</p>
<ol>
<li>News or otherweise short read</li>
<li>To-do or to-remember</li>
<li>Lenghty article</li>
</ol>
<p>Short articles can be read as soon as I process them. It usually takes longer to store them for later, and often the relevant tidbit of story is contained in the headline and first paragraph. Unless I deem a short article save-worthy for later, it is read and closed.</p>
<p>A to-do or to-remember are for example dates I sould keep track of or articles/tutorials outlining some action. They are stored in my prefered todo-list application (<a href="https://wunderlist.com">Wunderlist</a>), with date or reminder as needed.</p>
<p>Lengthy articles, or topics I feel the urge to check out, are either read or stored, depending if I have the time and desire to readt them right now, or if they apply to the topic I check out. Temporary storage for worked on links are browser tabs (with the chrome extension <a href="https://one-tab.com">OneTab</a>), while other links I want to attend later are collected in a read-later service (<a href="https://getpocket.com">Pocket</a>).</p>
<h1>Actions and storage</h1>
<p>The next step is to process the tabs, read-later articles and todos. Todos are automatically processed as they come up, either with a reminder, or as next natural challenge on my list.</p>
<p>For the read-later articles I have regular time-slots. Some freshly brewed black coffee, and then I read what seems the most interessting. If the time is up, the remaining articles have to wait till next time. While reading I try to take notes of the interessting ideas/facts, so I can later recall what it was about. Processed articles are then stored in a bookmarking-service (<a href="https://diigo.com">Diigo</a>), together with the notes. Notes can also wander in my wiki, if they contribute or start a new topic worth keeping near me.</p>
<p>Tabs are closed and used as the topic dictates. References/links and notes are written down in a wiki (<a href="https://zim-wiki.org/">Zim</a>). If the subject are worth a broader audience, I intend to write a blog post about it.</p>
<p>Fulltext article storage is something I contemplated about, but decided to be not worth the hassle. Diigo and <a href="https://pinboard.in">Pinboard</a> offer fulltext storage, there are solutions for Evernote, and storing locally as file is no problem at all, but I honestly have never really needed it. Just take (clear) enough notes, and consider the link as reference.</p>
<h1>Summary</h1>
<p>I hope this overview is helpful for someone else. It surely has helped me a lot for a more streamlined reading experience, and therefore more time to read more :)</p>
<p><img alt="Overview of my reading process" src="//cseyda.github.io/images/reading.png" style="width: 830px; height: auto;"/></p>
                <div class="clear"></div>

                <div class="info">
                    <a href="//cseyda.github.io/reading-flow.html">posted at 00:00</a>
                    &nbsp;&middot;&nbsp;<a href="//cseyda.github.io/category/reading.html" rel="tag">Reading</a>
                    &nbsp;&middot;
                    &nbsp;<a href="//cseyda.github.io/tag/reading.html" class="tags">reading</a>
                    &nbsp;<a href="//cseyda.github.io/tag/wiki.html" class="tags">wiki</a>
                    &nbsp;<a href="//cseyda.github.io/tag/bookmark.html" class="tags">bookmark</a>
                </div>
            </article>            <h4 class="date">Dez 06, 2013</h4>

            <article class="post">
                <h2 class="title">
                    <a href="//cseyda.github.io/master-thesis.html" rel="bookmark" title="Permanent Link to &quot;My master&#8217;s&nbsp;thesis&quot;">My master&#8217;s&nbsp;thesis</a>
                </h2>

                <h1>Comparison of graph-based and vector-space geographical topic detection</h1>
<p><a href="//cseyda.github.io/static/MA.pdf">Link to the <span class="caps">PDF</span></a></p>
<h2>Abstract</h2>
<p>The popularity of social networks like Facebook and Twitter, together with media sharing plattforms like Flickr and the ubiquity of modern smart phones and cameras with <span class="caps">GPS</span> sensors have lead to a vast amount of data with documents containing locations, text, and even more information. this data can be leveraged to optimise search results, perform targeted advertisement and even help people and authorities in case of nature catastrophes, for example as early warning systems. Geographic topic detection aims at providing meaningful topics for specific regions. One way to perform this task is to use a clustering algorithm with an appropriate distance function.</p>
<p>This thesis compares two such distance functions by performing <span class="caps">DBSCAN</span> and comparing the fount topics. A naive vector-based approach based on linear composition of a jaccard distance on a text vector, and a euclidean distance based on the location vector. The second approach uses a graph build with a Delaunay triangulation based on the location data, and additional nodes and edges based on the text data. A random walk method is then performed to determine the distances between points.</p>
<p>Another important part is the quantitative evaluation of the found geographic topics with four standard cluster quality measures, and how well the scores from these measures resemble die actual quality of the topics. Used and evaluated datasets contain up to one million points, which is very much compared to other works.</p>
<p>Results show that both distance function are able to perform basic geographic topic discovery, but the graph-based approach usually outperforms the vector-based approach. Cluster quality measures, especially Silhouette width, give a general indication of the goodness of the performed topic discovery, but are unfortunately not suitable for direct comparison with the used base distances.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="//cseyda.github.io/master-thesis.html">posted at 00:00</a>
                    &nbsp;&middot;&nbsp;<a href="//cseyda.github.io/category/python.html" rel="tag">Python</a>
                    &nbsp;&middot;
                    &nbsp;<a href="//cseyda.github.io/tag/pelican.html" class="tags">pelican</a>
                    &nbsp;<a href="//cseyda.github.io/tag/publishing.html" class="tags">publishing</a>
                </div>
            </article>            <h4 class="date">Mär 28, 2011</h4>

            <article class="post">
                <h2 class="title">
                    <a href="//cseyda.github.io/bachelor-thesis.html" rel="bookmark" title="Permanent Link to &quot;My bachelor&#8217;s&nbsp;thesis&quot;">My bachelor&#8217;s&nbsp;thesis</a>
                </h2>

                <h1>Estimation of Power Consumption of <span class="caps">DVFS</span>-Enabled Processors</h1>
<p><a href="//cseyda.github.io/static/BA.pdf">Link to the <span class="caps">PDF</span></a></p>
<h2>Abstract</h2>
<p>Saving energy is nowadays a critical factor, especially for data centers or high performance clusters which have a power consumption of several mega watts. The simple use of component energy saving mechanisms is not always possible, because this can lead to performance degradation. For this reason, high performance clusters are mainly not using them, even in low utilization phases. Modelling the power consumption of a component based on specific recordable values can help to find ways of saving energy or predicting the power consumption after replacing the component with a more efficient one.</p>
<p>One of the main power consumer on a recent system is the processor. This thesis presents a model of the power consumption of a processor based on its frequency and voltage. Comparisons with real world power consumption were done to evaluate the model. Furthermore a tracing library was extended to be able to log the processor frequency and idle states if available. Using the presented model and the trace files, a power estimator has been implemented being able to estimate the power consumption of the processor in the given trace file—or a more energy efficient processor—helping to motivate the usage of power saving mechanisms and energy efficient processors, and showing the long term potential for energy saving.</p>
                <div class="clear"></div>

                <div class="info">
                    <a href="//cseyda.github.io/bachelor-thesis.html">posted at 00:00</a>
                    &nbsp;&middot;&nbsp;<a href="//cseyda.github.io/category/python.html" rel="tag">Python</a>
                    &nbsp;&middot;
                    &nbsp;<a href="//cseyda.github.io/tag/pelican.html" class="tags">pelican</a>
                    &nbsp;<a href="//cseyda.github.io/tag/publishing.html" class="tags">publishing</a>
                </div>
            </article>

            <div class="clear"></div>
            <footer>
                <p>
                <a href="https://github.com/jody-frankowski/blue-penguin">Blue Penguin</a> Theme
                &middot;
                Powered by <a href="http://getpelican.com">Pelican</a>
                &middot;
                <a href="//cseyda.github.io/feeds/all.atom.xml" rel="alternate">Atom Feed</a>
            </footer>
        </div>
        <div class="clear"></div>
    </div>
</body>
</html>