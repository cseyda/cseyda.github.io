<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Personal blog of Christian Seyda</title><link href="//cseyda.github.io/" rel="alternate"></link><link href="//cseyda.github.io/feeds/all.atom.xml" rel="self"></link><id>//cseyda.github.io/</id><updated>2016-07-04T00:00:00+02:00</updated><entry><title>Surfstick and internet sharing with networkmanager</title><link href="//cseyda.github.io/surfstick-networkmanager.html" rel="alternate"></link><published>2016-07-04T00:00:00+02:00</published><author><name>Christian Seyda</name></author><id>tag:cseyda.github.io,2016-07-04:surfstick-networkmanager.html</id><summary type="html">&lt;p&gt;Wired internet broke after floodings. To bridge the time till all repairs are finished I received a K4203 SurfStick. Some instructions how to get it to work and share the internet connection follows.&lt;/p&gt;
&lt;h1&gt;K4203 SurfStick&lt;/h1&gt;
&lt;p&gt;This stick provides a wireless internet connection through &lt;span class="caps"&gt;UMTS&lt;/span&gt;. In my case it didn’t work out of the box. Upon insertion in an &lt;span class="caps"&gt;USB&lt;/span&gt; slot it registered itself as a &lt;span class="caps"&gt;CD&lt;/span&gt;-reader. Apparently &lt;span class="caps"&gt;USB&lt;/span&gt; devices can have different modes of operation and change according to the situation. To force it to the right mode, watch with &lt;code&gt;lsusb&lt;/code&gt; and issue the following command after insertion of the stick:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ sudo usb_modeswitch -v 12d1 -p 1f1c -W -I -M 55534243123456780000000000000011062000000101000100000000000000
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="http://www.draisberghof.de/usb_modeswitch/bb/viewtopic.php?f=3&amp;amp;t=1970"&gt;Source&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;Internet sharing&lt;/h1&gt;
&lt;p&gt;There are tons of tutorials on how to share a internet connection with networkmanager — not repeating the steps here. But there is not enough information about how to change the standard &lt;span class="caps"&gt;IP&lt;/span&gt; address 10.42.0.1 of the shared interface.&lt;/p&gt;
&lt;p&gt;In order to use the shared connection, you have to change the addresses (&lt;span class="caps"&gt;IP&lt;/span&gt;, gateway, &lt;span class="caps"&gt;DNS&lt;/span&gt;) of all devices wanting to use it. There is no option in the &lt;span class="caps"&gt;GUI&lt;/span&gt; to change the standard address, and no configuration file option. The only way (I could find) was to use nmcli:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ nmcli connection modify Hotspot ipv4.address 196.168.0.1/24
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href="https://www.mail-archive.com/networkmanager-list@gnome.org/msg26190.html"&gt;Source&lt;/a&gt;&lt;/p&gt;</summary><category term="software"></category><category term="network"></category><category term="linux"></category></entry><entry><title>Podcasts under linux, a short example</title><link href="//cseyda.github.io/podcasts-linux.html" rel="alternate"></link><published>2016-06-25T00:00:00+02:00</published><author><name>Christian Seyda</name></author><id>tag:cseyda.github.io,2016-06-25:podcasts-linux.html</id><summary type="html">&lt;p&gt;I recently started listening to podcasts. Intrigued by the usual promises of learning things, gaining perspectives and finding inspiration, there was luckily little friction in finding, getting and hearing them on linux. Only syncing to my mp3-player is a bit of a hassle.&lt;/p&gt;
&lt;h1&gt;What are podcasts, why should you listen to them and when?&lt;/h1&gt;
&lt;p&gt;Podcasts are modern radio shows.&lt;/p&gt;
&lt;p&gt;What internet videos/shows are to &lt;span class="caps"&gt;TV&lt;/span&gt;, podcasts are to radio shows. You hear them when you want, and how you want (pause, skip, rewind, …). There is a huge variety of themes, because everybody can start a podcast. Episodes don’t have to fit in any schedule, so the episodes of different shows vary quite in length.&lt;/p&gt;
&lt;p&gt;The usual appeal, like radio, comes from a slight shift in perspective in contrast to video, or books. There are many interviews, and the hosts talk more directly to the listener. Podcasts, as a different medium, attracts different people. People more inclined to text (like writers and journalists), which usually don’t produce video, more often produce podcasts, or be a guest on a show.&lt;/p&gt;
&lt;p&gt;Because podcasts are usually listened to while your body is occupied, but your mind may not. For example you could listen while training/running, household activities, preparing food, travelling, … You could of course listen to a podcast while doing nothing else. It is definitely not worse than watching &lt;span class="caps"&gt;TV&lt;/span&gt;.&lt;/p&gt;
&lt;h1&gt;How are they working / overview&lt;/h1&gt;
&lt;p&gt;Handling podcasts as a user is comparable to handling news feeds, because podcast services right now are implemented usually with feeds (&lt;span class="caps"&gt;RSS&lt;/span&gt;/atom).&lt;/p&gt;
&lt;p&gt;Therefore, there are 3 parts involved:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Finding podcasts / recommendation service,&lt;/li&gt;
&lt;li&gt;getting new episodes, and&lt;/li&gt;
&lt;li&gt;listening to / streaming / syncing episodes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Because podcast are exploding in popularity, there are quite a few apps and platforms specifically designed for finding, managing and listening to podcasts (like Feedly/Inoreader for feeds). The biggest one is iTunes. Most podcasts also have a website, where you can find the feed url. Sometimes there are integrated players for listening on the page, and/or materials/notes used by the show.&lt;/p&gt;
&lt;p&gt;There are also programs designed for each part, which is “more in line” with the &lt;span class="caps"&gt;UNIX&lt;/span&gt; philosophy of “do one thing, but do it well”.&lt;/p&gt;
&lt;h1&gt;My use case&lt;/h1&gt;
&lt;p&gt;With no no smartphone, but a mp3-player, I needed a desktop + sync solution.&lt;/p&gt;
&lt;p&gt;There are many good clients available for finding podcast and managing episode downloads, because the techniques (feeds, downloads) are well understood. Syncing is unfortunately a different topic.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For getting the subscription link: &lt;a href="http://tunesviewer.sourceforge.net/"&gt;Tunesviewer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;With Tunesviewer you can surf the iTunes archive/website without the iTunes client, and get the feed link for each show. (You can think about Apple what you want, but iTunes with Tunesviewer for podcasts is really convenient, even if there are other platforms available.)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For getting the episodes: &lt;a href="http://gpodder.org/"&gt;gPodder&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;gPodder is a really good working graphical podcatcher: insert url, choose episodes and download them.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;For syncing: gPodder + custom script&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Syncing in my case is at least:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Download new episode -&amp;gt; transfer to device&lt;/li&gt;
&lt;li&gt;Mark episode listened -&amp;gt; delete on device&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;gPodder sync support works for case 1., but unfortunately not for case 2.&lt;/p&gt;
&lt;p&gt;I ended up with a small Python script. gPodder saves its information of podcasts/episodes in an sqlite database. The script generates the filenames of episodes which are not heard yet, compares these with the filenames on my mp3-player, and deletes those not needed anymore.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;Podcast are great. They are generally easy to manage. And with the right tools custom solutions or tweaks are easy to make.&lt;/p&gt;</summary><category term="podcast"></category><category term="software"></category><category term="learning"></category><category term="linux"></category></entry><entry><title>My article reading and consumption flow</title><link href="//cseyda.github.io/reading-flow.html" rel="alternate"></link><published>2016-04-17T00:00:00+02:00</published><author><name>Christian Seyda</name></author><id>tag:cseyda.github.io,2016-04-17:reading-flow.html</id><summary type="html">&lt;p&gt;It was too much. Articles in bookmarks, open tabs, tab groups, sometimes over different browsers and operating systems and even in my todo list … This had to to change. A process for reading was needed.
First step was to open even more tabs and add more bookmarks. But after some reading how others approach this topic, I got to work uncluttering this mess.&lt;/p&gt;
&lt;p&gt;In hindsight, the whole process is pretty obvious. It basically works this way:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Articles come in&lt;/li&gt;
&lt;li&gt;Some are read, some are added to a read-later list&lt;/li&gt;
&lt;li&gt;Later, articles from the read-later list are read&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;My implementation is a little more complex, because I added a research process and wanted to take more notes of what I learned (and because I am a complicated person?).&lt;/p&gt;
&lt;p&gt;The resulting reading flow can be devided into different parts:&lt;/p&gt;
&lt;h1&gt;Documents and decisions&lt;/h1&gt;
&lt;p&gt;Usually all articles I read either come from the links gathered by looking something up in my browser, or though my feed reader (&lt;a href="https://inoreader.com"&gt;InoReader&lt;/a&gt;). These articles can be roughly divided into three types:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;News or otherweise short read&lt;/li&gt;
&lt;li&gt;To-do or to-remember&lt;/li&gt;
&lt;li&gt;Lenghty article&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Short articles can be read as soon as I process them. It usually takes longer to store them for later, and often the relevant tidbit of story is contained in the headline and first paragraph. Unless I deem a short article save-worthy for later, it is read and closed.&lt;/p&gt;
&lt;p&gt;A to-do or to-remember are for example dates I sould keep track of or articles/tutorials outlining some action. They are stored in my prefered todo-list application (&lt;a href="https://wunderlist.com"&gt;Wunderlist&lt;/a&gt;), with date or reminder as needed.&lt;/p&gt;
&lt;p&gt;Lengthy articles, or topics I feel the urge to check out, are either read or stored, depending if I have the time and desire to readt them right now, or if they apply to the topic I check out. Temporary storage for worked on links are browser tabs (with the chrome extension &lt;a href="https://one-tab.com"&gt;OneTab&lt;/a&gt;), while other links I want to attend later are collected in a read-later service (&lt;a href="https://getpocket.com"&gt;Pocket&lt;/a&gt;).&lt;/p&gt;
&lt;h1&gt;Actions and storage&lt;/h1&gt;
&lt;p&gt;The next step is to process the tabs, read-later articles and todos. Todos are automatically processed as they come up, either with a reminder, or as next natural challenge on my list.&lt;/p&gt;
&lt;p&gt;For the read-later articles I have regular time-slots. Some freshly brewed black coffee, and then I read what seems the most interessting. If the time is up, the remaining articles have to wait till next time. While reading I try to take notes of the interessting ideas/facts, so I can later recall what it was about. Processed articles are then stored in a bookmarking-service (&lt;a href="https://diigo.com"&gt;Diigo&lt;/a&gt;), together with the notes. Notes can also wander in my wiki, if they contribute or start a new topic worth keeping near me.&lt;/p&gt;
&lt;p&gt;Tabs are closed and used as the topic dictates. References/links and notes are written down in a wiki (&lt;a href="https://zim-wiki.org/"&gt;Zim&lt;/a&gt;). If the subject are worth a broader audience, I intend to write a blog post about it.&lt;/p&gt;
&lt;p&gt;Fulltext article storage is something I contemplated about, but decided to be not worth the hassle. Diigo and &lt;a href="https://pinboard.in"&gt;Pinboard&lt;/a&gt; offer fulltext storage, there are solutions for Evernote, and storing locally as file is no problem at all, but I honestly have never really needed it. Just take (clear) enough notes, and consider the link as reference.&lt;/p&gt;
&lt;h1&gt;Summary&lt;/h1&gt;
&lt;p&gt;I hope this overview is helpful for someone else. It surely has helped me a lot for a more streamlined reading experience, and therefore more time to read more :)&lt;/p&gt;
&lt;p&gt;&lt;img alt="Overview of my reading process" src="//cseyda.github.io/images/reading.png" style="width: 830px; height: auto;"/&gt;&lt;/p&gt;</summary><category term="reading"></category><category term="wiki"></category><category term="bookmark"></category></entry><entry><title>My master’s thesis</title><link href="//cseyda.github.io/master-thesis.html" rel="alternate"></link><published>2013-12-06T00:00:00+01:00</published><author><name>Christian Seyda</name></author><id>tag:cseyda.github.io,2013-12-06:master-thesis.html</id><summary type="html">&lt;h1&gt;Comparison of graph-based and vector-space geographical topic detection&lt;/h1&gt;
&lt;p&gt;&lt;a href="//cseyda.github.io/static/MA.pdf"&gt;Link to the &lt;span class="caps"&gt;PDF&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Abstract&lt;/h2&gt;
&lt;p&gt;The popularity of social networks like Facebook and Twitter, together with media sharing plattforms like Flickr and the ubiquity of modern smart phones and cameras with &lt;span class="caps"&gt;GPS&lt;/span&gt; sensors have lead to a vast amount of data with documents containing locations, text, and even more information. this data can be leveraged to optimise search results, perform targeted advertisement and even help people and authorities in case of nature catastrophes, for example as early warning systems. Geographic topic detection aims at providing meaningful topics for specific regions. One way to perform this task is to use a clustering algorithm with an appropriate distance function.&lt;/p&gt;
&lt;p&gt;This thesis compares two such distance functions by performing &lt;span class="caps"&gt;DBSCAN&lt;/span&gt; and comparing the fount topics. A naive vector-based approach based on linear composition of a jaccard distance on a text vector, and a euclidean distance based on the location vector. The second approach uses a graph build with a Delaunay triangulation based on the location data, and additional nodes and edges based on the text data. A random walk method is then performed to determine the distances between points.&lt;/p&gt;
&lt;p&gt;Another important part is the quantitative evaluation of the found geographic topics with four standard cluster quality measures, and how well the scores from these measures resemble die actual quality of the topics. Used and evaluated datasets contain up to one million points, which is very much compared to other works.&lt;/p&gt;
&lt;p&gt;Results show that both distance function are able to perform basic geographic topic discovery, but the graph-based approach usually outperforms the vector-based approach. Cluster quality measures, especially Silhouette width, give a general indication of the goodness of the performed topic discovery, but are unfortunately not suitable for direct comparison with the used base distances.&lt;/p&gt;</summary><category term="pelican"></category><category term="publishing"></category></entry><entry><title>My bachelor’s thesis</title><link href="//cseyda.github.io/bachelor-thesis.html" rel="alternate"></link><published>2011-03-28T00:00:00+02:00</published><author><name>Christian Seyda</name></author><id>tag:cseyda.github.io,2011-03-28:bachelor-thesis.html</id><summary type="html">&lt;h1&gt;Estimation of Power Consumption of &lt;span class="caps"&gt;DVFS&lt;/span&gt;-Enabled Processors&lt;/h1&gt;
&lt;p&gt;&lt;a href="//cseyda.github.io/static/BA.pdf"&gt;Link to the &lt;span class="caps"&gt;PDF&lt;/span&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;Abstract&lt;/h2&gt;
&lt;p&gt;Saving energy is nowadays a critical factor, especially for data centers or high performance clusters which have a power consumption of several mega watts. The simple use of component energy saving mechanisms is not always possible, because this can lead to performance degradation. For this reason, high performance clusters are mainly not using them, even in low utilization phases. Modelling the power consumption of a component based on specific recordable values can help to find ways of saving energy or predicting the power consumption after replacing the component with a more efficient one.&lt;/p&gt;
&lt;p&gt;One of the main power consumer on a recent system is the processor. This thesis presents a model of the power consumption of a processor based on its frequency and voltage. Comparisons with real world power consumption were done to evaluate the model. Furthermore a tracing library was extended to be able to log the processor frequency and idle states if available. Using the presented model and the trace files, a power estimator has been implemented being able to estimate the power consumption of the processor in the given trace file—or a more energy efficient processor—helping to motivate the usage of power saving mechanisms and energy efficient processors, and showing the long term potential for energy saving.&lt;/p&gt;</summary><category term="pelican"></category><category term="publishing"></category></entry></feed>